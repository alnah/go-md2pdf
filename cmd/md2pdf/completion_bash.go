package main

import (
	"fmt"
	"io"
	"strings"
)

// generateBash generates Bash completion script.
func generateBash(w io.Writer) error {
	var b strings.Builder

	b.WriteString(`# Bash completion for md2pdf
# Generated by md2pdf completion bash

_md2pdf_completions() {
    local cur prev words cword
    _init_completion || return

    local commands="`)

	// Write command names
	for i, cmd := range getCommands() {
		if i > 0 {
			b.WriteString(" ")
		}
		b.WriteString(cmd.Name)
	}
	b.WriteString(`"

    # Handle completion based on position and previous word
    case "${cword}" in
        1)
            # First argument: complete commands
            COMPREPLY=($(compgen -W "${commands}" -- "${cur}"))
            return
            ;;
    esac

    # Get the command (first argument after md2pdf)
    local cmd="${words[1]}"

    case "${cmd}" in
`)

	// Generate case for each command
	for _, cmd := range getCommands() {
		b.WriteString(fmt.Sprintf("        %s)\n", cmd.Name))
		if cmd.Name == "help" {
			// help completes with command names
			b.WriteString(`            COMPREPLY=($(compgen -W "${commands}" -- "${cur}"))
            return
            ;;
`)
			continue
		}
		if cmd.Name == "completion" {
			// completion completes with shell names
			b.WriteString(`            COMPREPLY=($(compgen -W "bash zsh fish powershell" -- "${cur}"))
            return
            ;;
`)
			continue
		}
		if len(cmd.Flags) == 0 && !cmd.TakesFiles {
			b.WriteString(`            return
            ;;
`)
			continue
		}

		// Generate flag completions
		generateBashCommandCase(&b, cmd)
		b.WriteString("            ;;\n")
	}

	b.WriteString(`    esac
}

# Helper: complete files matching glob patterns
_md2pdf_complete_files() {
    local patterns="$1"
    local IFS=','
    local result=()
    for pattern in $patterns; do
        # Use compgen with glob
        local files=$(compgen -f -- "${cur}" 2>/dev/null | grep -E "\.(${pattern#*.})$" 2>/dev/null)
        if [[ -n "$files" ]]; then
            result+=($files)
        fi
    done
    # Also complete directories for navigation
    local dirs=$(compgen -d -- "${cur}" 2>/dev/null)
    if [[ -n "$dirs" ]]; then
        result+=($dirs)
    fi
    COMPREPLY=(${result[@]})
}

# Helper: complete directories
_md2pdf_complete_dirs() {
    COMPREPLY=($(compgen -d -- "${cur}"))
}

complete -F _md2pdf_completions md2pdf
`)

	_, err := w.Write([]byte(b.String()))
	return err
}

// generateBashCommandCase generates the case body for a command.
func generateBashCommandCase(b *strings.Builder, cmd commandDef) {
	// Build flag lists by type
	var allFlags []string
	enumFlags := make(map[string][]string) // flag -> values
	fileFlags := make(map[string]string)   // flag -> glob
	var dirFlags []string

	for _, f := range cmd.Flags {
		allFlags = append(allFlags, "--"+f.Long)
		if f.Short != "" {
			allFlags = append(allFlags, "-"+f.Short)
		}

		switch f.Type {
		case flagEnum:
			enumFlags["--"+f.Long] = f.Values
			if f.Short != "" {
				enumFlags["-"+f.Short] = f.Values
			}
		case flagFile:
			fileFlags["--"+f.Long] = f.FileGlob
			if f.Short != "" {
				fileFlags["-"+f.Short] = f.FileGlob
			}
		case flagDir:
			dirFlags = append(dirFlags, "--"+f.Long)
			if f.Short != "" {
				dirFlags = append(dirFlags, "-"+f.Short)
			}
		}
	}

	// Handle previous word (flag value completion)
	b.WriteString("            case \"${prev}\" in\n")

	// Enum flags
	for flag, values := range enumFlags {
		b.WriteString(fmt.Sprintf("                %s)\n", flag))
		b.WriteString(fmt.Sprintf("                    COMPREPLY=($(compgen -W \"%s\" -- \"${cur}\"))\n", strings.Join(values, " ")))
		b.WriteString("                    return\n")
		b.WriteString("                    ;;\n")
	}

	// File flags
	for flag, glob := range fileFlags {
		b.WriteString(fmt.Sprintf("                %s)\n", flag))
		b.WriteString(fmt.Sprintf("                    _md2pdf_complete_files \"%s\"\n", glob))
		b.WriteString("                    return\n")
		b.WriteString("                    ;;\n")
	}

	// Dir flags
	for _, flag := range dirFlags {
		b.WriteString(fmt.Sprintf("                %s)\n", flag))
		b.WriteString("                    _md2pdf_complete_dirs\n")
		b.WriteString("                    return\n")
		b.WriteString("                    ;;\n")
	}

	b.WriteString("            esac\n\n")

	// Current word completion
	b.WriteString("            # Complete flags or files\n")
	b.WriteString("            if [[ \"${cur}\" == -* ]]; then\n")
	b.WriteString(fmt.Sprintf("                COMPREPLY=($(compgen -W \"%s\" -- \"${cur}\"))\n", strings.Join(allFlags, " ")))
	b.WriteString("            else\n")
	if cmd.TakesFiles && cmd.FilePattern != "" {
		b.WriteString(fmt.Sprintf("                _md2pdf_complete_files \"%s\"\n", cmd.FilePattern))
	} else {
		b.WriteString("                COMPREPLY=()\n")
	}
	b.WriteString("            fi\n")
}
