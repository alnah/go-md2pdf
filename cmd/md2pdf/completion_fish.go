package main

import (
	"fmt"
	"io"
	"strings"
)

// generateFish generates Fish completion script.
func generateFish(w io.Writer) error {
	var b strings.Builder

	b.WriteString(`# Fish completion for md2pdf
# Generated by md2pdf completion fish

# Disable file completion by default
complete -c md2pdf -f

# Helper function to check if a subcommand is already specified
function __fish_md2pdf_needs_command
    set -l cmd (commandline -opc)
    if test (count $cmd) -eq 1
        return 0
    end
    return 1
end

function __fish_md2pdf_using_command
    set -l cmd (commandline -opc)
    if test (count $cmd) -gt 1
        if test "$argv[1]" = "$cmd[2]"
            return 0
        end
    end
    return 1
end

# Commands
`)

	// Generate command completions
	for _, cmd := range getCommands() {
		b.WriteString(fmt.Sprintf("complete -c md2pdf -n __fish_md2pdf_needs_command -a %s -d '%s'\n",
			cmd.Name, escapeFishDesc(cmd.Desc)))
	}

	b.WriteString("\n# Subcommand: help\n")
	for _, cmd := range getCommands() {
		b.WriteString(fmt.Sprintf("complete -c md2pdf -n '__fish_md2pdf_using_command help' -a %s -d '%s'\n",
			cmd.Name, escapeFishDesc(cmd.Desc)))
	}

	b.WriteString("\n# Subcommand: completion\n")
	b.WriteString("complete -c md2pdf -n '__fish_md2pdf_using_command completion' -a bash -d 'Bash completion script'\n")
	b.WriteString("complete -c md2pdf -n '__fish_md2pdf_using_command completion' -a zsh -d 'Zsh completion script'\n")
	b.WriteString("complete -c md2pdf -n '__fish_md2pdf_using_command completion' -a fish -d 'Fish completion script'\n")
	b.WriteString("complete -c md2pdf -n '__fish_md2pdf_using_command completion' -a powershell -d 'PowerShell completion script'\n")

	// Generate flag completions for convert command
	for _, cmd := range getCommands() {
		if len(cmd.Flags) == 0 {
			continue
		}

		b.WriteString(fmt.Sprintf("\n# Subcommand: %s\n", cmd.Name))
		generateFishCommandFlags(&b, cmd)
	}

	_, err := w.Write([]byte(b.String()))
	return err
}

// generateFishCommandFlags generates flag completions for a command.
func generateFishCommandFlags(b *strings.Builder, cmd commandDef) {
	condition := fmt.Sprintf("__fish_md2pdf_using_command %s", cmd.Name)

	for _, f := range cmd.Flags {
		var parts []string
		parts = append(parts, "complete", "-c", "md2pdf")
		parts = append(parts, "-n", fmt.Sprintf("'%s'", condition))

		// Long flag
		parts = append(parts, "-l", f.Long)

		// Short flag
		if f.Short != "" {
			parts = append(parts, "-s", f.Short)
		}

		// Description
		parts = append(parts, "-d", fmt.Sprintf("'%s'", escapeFishDesc(f.Desc)))

		// Type-specific options
		switch f.Type {
		case flagBool:
			// No argument required
		case flagEnum:
			parts = append(parts, "-x") // exclusive (no file completion)
			parts = append(parts, "-a", fmt.Sprintf("'%s'", strings.Join(f.Values, " ")))
		case flagFile:
			parts = append(parts, "-r") // requires argument
			parts = append(parts, "-F") // allow file completion
			// Fish doesn't have built-in glob filtering, but -F enables file completion
		case flagDir:
			parts = append(parts, "-r") // requires argument
			parts = append(parts, "-a", "'(__fish_complete_directories)'")
		default: // string, int, float
			parts = append(parts, "-r") // requires argument
		}

		b.WriteString(strings.Join(parts, " "))
		b.WriteString("\n")
	}

	// Add file argument completion for commands that take files
	if cmd.TakesFiles && cmd.FilePattern != "" {
		// Enable file completion for positional arguments
		patterns := strings.Split(cmd.FilePattern, ",")
		for _, pattern := range patterns {
			// Extract extension from pattern (e.g., "*.md" -> "md")
			ext := strings.TrimPrefix(pattern, "*.")
			b.WriteString(fmt.Sprintf("complete -c md2pdf -n '%s' -a '(for f in *.%s; echo $f; end)' -d 'Markdown file'\n",
				condition, ext))
		}
	}
}

// escapeFishDesc escapes special characters for fish shell.
func escapeFishDesc(s string) string {
	s = strings.ReplaceAll(s, "\\", "\\\\") // Escape backslash first
	s = strings.ReplaceAll(s, "'", "\\'")
	return s
}
