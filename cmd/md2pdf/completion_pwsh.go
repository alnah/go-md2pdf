package main

import (
	"fmt"
	"io"
	"strings"
)

// generatePowerShell generates PowerShell completion script.
func generatePowerShell(w io.Writer) error {
	var b strings.Builder

	b.WriteString(`# PowerShell completion for md2pdf
# Generated by md2pdf completion powershell

using namespace System.Management.Automation
using namespace System.Management.Automation.Language

Register-ArgumentCompleter -Native -CommandName md2pdf -ScriptBlock {
    param($wordToComplete, $commandAst, $cursorPosition)

    $commands = @(
`)

	// Generate command definitions
	for _, cmd := range getCommands() {
		b.WriteString(fmt.Sprintf("        @{ Name = '%s'; Description = '%s' }\n",
			cmd.Name, escapePwshString(cmd.Desc)))
	}

	b.WriteString(`    )

    $commandFlags = @{
`)

	// Generate flag definitions per command
	for _, cmd := range getCommands() {
		if len(cmd.Flags) == 0 {
			continue
		}

		b.WriteString(fmt.Sprintf("        '%s' = @(\n", cmd.Name))
		for _, f := range cmd.Flags {
			b.WriteString(fmt.Sprintf("            @{ Name = '--%s'", f.Long))
			if f.Short != "" {
				b.WriteString(fmt.Sprintf("; Short = '-%s'", f.Short))
			}
			b.WriteString(fmt.Sprintf("; Description = '%s'", escapePwshString(f.Desc)))
			b.WriteString(fmt.Sprintf("; Type = '%s'", pwshFlagType(f.Type)))
			if f.Type == flagEnum {
				b.WriteString(fmt.Sprintf("; Values = @('%s')", strings.Join(f.Values, "', '")))
			}
			if f.Type == flagFile && f.FileGlob != "" {
				b.WriteString(fmt.Sprintf("; FileGlob = '%s'", f.FileGlob))
			}
			b.WriteString(" }\n")
		}
		b.WriteString("        )\n")
	}

	b.WriteString(`    }

    $commandFilePatterns = @{
`)

	// Generate file patterns for commands
	for _, cmd := range getCommands() {
		if cmd.TakesFiles && cmd.FilePattern != "" {
			b.WriteString(fmt.Sprintf("        '%s' = '%s'\n", cmd.Name, cmd.FilePattern))
		}
	}

	b.WriteString(`    }

    # Parse the command line
    $tokens = $commandAst.CommandElements
    $command = $null
    $lastFlag = $null

    for ($i = 1; $i -lt $tokens.Count; $i++) {
        $token = $tokens[$i].ToString()
        if ($token -notlike '-*' -and $null -eq $command) {
            $command = $token
        }
        if ($token -like '-*') {
            $lastFlag = $token
        }
    }

    # Determine what to complete
    $completions = @()

    # If no command yet, complete commands
    if ($null -eq $command -or ($wordToComplete -ne '' -and $tokens.Count -eq 2)) {
        $completions = $commands | Where-Object { $_.Name -like "$wordToComplete*" } | ForEach-Object {
            [CompletionResult]::new($_.Name, $_.Name, 'ParameterValue', $_.Description)
        }
    }
    # Complete help subcommand
    elseif ($command -eq 'help') {
        $completions = $commands | Where-Object { $_.Name -like "$wordToComplete*" } | ForEach-Object {
            [CompletionResult]::new($_.Name, $_.Name, 'ParameterValue', $_.Description)
        }
    }
    # Complete shell names for completion command
    elseif ($command -eq 'completion') {
        $shells = @(
            @{ Name = 'bash'; Description = 'Bash completion script' }
            @{ Name = 'zsh'; Description = 'Zsh completion script' }
            @{ Name = 'fish'; Description = 'Fish completion script' }
            @{ Name = 'powershell'; Description = 'PowerShell completion script' }
        )
        $completions = $shells | Where-Object { $_.Name -like "$wordToComplete*" } | ForEach-Object {
            [CompletionResult]::new($_.Name, $_.Name, 'ParameterValue', $_.Description)
        }
    }
    # Complete flags or flag values
    elseif ($commandFlags.ContainsKey($command)) {
        $flags = $commandFlags[$command]

        # Check if we're completing a flag value
        if ($lastFlag -and $wordToComplete -notlike '-*') {
            $flag = $flags | Where-Object { $_.Name -eq $lastFlag -or $_.Short -eq $lastFlag } | Select-Object -First 1
            if ($flag) {
                switch ($flag.Type) {
                    'enum' {
                        $completions = $flag.Values | Where-Object { $_ -like "$wordToComplete*" } | ForEach-Object {
                            [CompletionResult]::new($_, $_, 'ParameterValue', $_)
                        }
                    }
                    'file' {
                        # Complete files matching glob
                        $patterns = $flag.FileGlob -split ','
                        foreach ($pattern in $patterns) {
                            Get-ChildItem -Path "$wordToComplete*" -File -ErrorAction SilentlyContinue |
                                Where-Object { $_.Name -like $pattern } |
                                ForEach-Object {
                                    $completions += [CompletionResult]::new($_.Name, $_.Name, 'ProviderItem', $_.Name)
                                }
                        }
                        # Also complete directories for navigation
                        Get-ChildItem -Path "$wordToComplete*" -Directory -ErrorAction SilentlyContinue |
                            ForEach-Object {
                                $completions += [CompletionResult]::new($_.Name + '\', $_.Name, 'ProviderContainer', $_.Name)
                            }
                    }
                    'dir' {
                        Get-ChildItem -Path "$wordToComplete*" -Directory -ErrorAction SilentlyContinue |
                            ForEach-Object {
                                $completions += [CompletionResult]::new($_.Name + '\', $_.Name, 'ProviderContainer', $_.Name)
                            }
                    }
                }
            }
        }
        # Complete flags
        elseif ($wordToComplete -like '-*' -or $wordToComplete -eq '') {
            $completions = $flags | Where-Object { $_.Name -like "$wordToComplete*" } | ForEach-Object {
                [CompletionResult]::new($_.Name, $_.Name, 'ParameterName', $_.Description)
            }
        }
        # Complete files for positional arguments
        else {
            if ($commandFilePatterns.ContainsKey($command)) {
                $patterns = $commandFilePatterns[$command] -split ','
                foreach ($pattern in $patterns) {
                    Get-ChildItem -Path "$wordToComplete*" -File -ErrorAction SilentlyContinue |
                        Where-Object { $_.Name -like $pattern } |
                        ForEach-Object {
                            $completions += [CompletionResult]::new($_.Name, $_.Name, 'ProviderItem', $_.Name)
                        }
                }
                # Also complete directories for navigation
                Get-ChildItem -Path "$wordToComplete*" -Directory -ErrorAction SilentlyContinue |
                    ForEach-Object {
                        $completions += [CompletionResult]::new($_.Name + '\', $_.Name, 'ProviderContainer', $_.Name)
                    }
            }
        }
    }

    $completions
}
`)

	_, err := w.Write([]byte(b.String()))
	return err
}

// pwshFlagType returns the PowerShell type name for a flag type.
func pwshFlagType(t flagType) string {
	switch t {
	case flagBool:
		return "bool"
	case flagEnum:
		return "enum"
	case flagFile:
		return "file"
	case flagDir:
		return "dir"
	case flagInt:
		return "int"
	case flagFloat:
		return "float"
	default:
		return "string"
	}
}

// escapePwshString escapes special characters for PowerShell strings.
func escapePwshString(s string) string {
	s = strings.ReplaceAll(s, "'", "''")
	return s
}
