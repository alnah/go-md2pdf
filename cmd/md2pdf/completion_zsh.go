package main

import (
	"fmt"
	"io"
	"strings"
)

// generateZsh generates Zsh completion script.
func generateZsh(w io.Writer) error {
	var b strings.Builder

	b.WriteString(`#compdef md2pdf
# Zsh completion for md2pdf
# Generated by md2pdf completion zsh

_md2pdf() {
    local curcontext="$curcontext" state line
    typeset -A opt_args

    _arguments -C \
        '1: :->command' \
        '*: :->args'

    case $state in
        command)
            local commands=(
`)

	// Write commands with descriptions
	for _, cmd := range getCommands() {
		b.WriteString(fmt.Sprintf("                '%s:%s'\n", cmd.Name, escapeZshDesc(cmd.Desc)))
	}

	b.WriteString(`            )
            _describe 'command' commands
            ;;
        args)
            case $words[2] in
`)

	// Generate case for each command
	for _, cmd := range getCommands() {
		b.WriteString(fmt.Sprintf("                %s)\n", cmd.Name))
		if cmd.Name == "help" {
			b.WriteString(`                    local commands=(
`)
			for _, c := range getCommands() {
				b.WriteString(fmt.Sprintf("                        '%s:%s'\n", c.Name, escapeZshDesc(c.Desc)))
			}
			b.WriteString(`                    )
                    _describe 'command' commands
                    ;;
`)
			continue
		}
		if cmd.Name == "completion" {
			b.WriteString(`                    local shells=(
                        'bash:Bash completion script'
                        'zsh:Zsh completion script'
                        'fish:Fish completion script'
                        'powershell:PowerShell completion script'
                    )
                    _describe 'shell' shells
                    ;;
`)
			continue
		}
		if len(cmd.Flags) == 0 && !cmd.TakesFiles {
			b.WriteString("                    ;;\n")
			continue
		}

		generateZshCommandCase(&b, cmd)
		b.WriteString("                    ;;\n")
	}

	b.WriteString(`            esac
            ;;
    esac
}

# Register the completion function
compdef _md2pdf md2pdf
`)

	_, err := w.Write([]byte(b.String()))
	return err
}

// generateZshCommandCase generates the completion arguments for a command.
func generateZshCommandCase(b *strings.Builder, cmd commandDef) {
	b.WriteString("                    _arguments -s \\\n")

	for i, f := range cmd.Flags {
		trailing := " \\"
		if i == len(cmd.Flags)-1 && !cmd.TakesFiles {
			trailing = ""
		}

		// Build the argument spec
		var spec string
		switch f.Type {
		case flagBool:
			if f.Short != "" {
				spec = fmt.Sprintf("'(-%s --%s)'{-%s,--%s}'[%s]'",
					f.Short, f.Long, f.Short, f.Long, escapeZshDesc(f.Desc))
			} else {
				spec = fmt.Sprintf("'--%s[%s]'", f.Long, escapeZshDesc(f.Desc))
			}
		case flagEnum:
			values := strings.Join(f.Values, " ")
			if f.Short != "" {
				spec = fmt.Sprintf("'(-%s --%s)'{-%s,--%s}'[%s]:value:(%s)'",
					f.Short, f.Long, f.Short, f.Long, escapeZshDesc(f.Desc), values)
			} else {
				spec = fmt.Sprintf("'--%s[%s]:value:(%s)'", f.Long, escapeZshDesc(f.Desc), values)
			}
		case flagFile:
			fileSpec := zshFileSpec(f.FileGlob)
			if f.Short != "" {
				spec = fmt.Sprintf("'(-%s --%s)'{-%s,--%s}'[%s]:file:%s'",
					f.Short, f.Long, f.Short, f.Long, escapeZshDesc(f.Desc), fileSpec)
			} else {
				spec = fmt.Sprintf("'--%s[%s]:file:%s'", f.Long, escapeZshDesc(f.Desc), fileSpec)
			}
		case flagDir:
			if f.Short != "" {
				spec = fmt.Sprintf("'(-%s --%s)'{-%s,--%s}'[%s]:directory:_files -/'",
					f.Short, f.Long, f.Short, f.Long, escapeZshDesc(f.Desc))
			} else {
				spec = fmt.Sprintf("'--%s[%s]:directory:_files -/'", f.Long, escapeZshDesc(f.Desc))
			}
		default: // string, int, float
			if f.Short != "" {
				spec = fmt.Sprintf("'(-%s --%s)'{-%s,--%s}'[%s]:value:'",
					f.Short, f.Long, f.Short, f.Long, escapeZshDesc(f.Desc))
			} else {
				spec = fmt.Sprintf("'--%s[%s]:value:'", f.Long, escapeZshDesc(f.Desc))
			}
		}

		b.WriteString(fmt.Sprintf("                        %s%s\n", spec, trailing))
	}

	// Add file argument completion
	if cmd.TakesFiles {
		fileSpec := zshFileSpec(cmd.FilePattern)
		b.WriteString(fmt.Sprintf("                        '*:input file:%s'\n", fileSpec))
	}
}

// escapeZshDesc escapes special characters in descriptions for zsh.
func escapeZshDesc(s string) string {
	s = strings.ReplaceAll(s, "'", "'\\''")
	s = strings.ReplaceAll(s, "[", "\\[")
	s = strings.ReplaceAll(s, "]", "\\]")
	s = strings.ReplaceAll(s, ":", "\\:")
	return s
}

// zshFileSpec converts a glob pattern to zsh file completion spec.
// Note: We use simple _files without -g to avoid quoting issues in _arguments.
// The glob filtering is a nice-to-have; basic file completion is more important.
// The glob parameter is intentionally unused - kept for future enhancement.
func zshFileSpec(_ string) string {
	return "_files"
}
